import { merge } from 'lodash';
import { ObjectId } from 'mongodb';
import { arrayToObject, convertType, formatValue } from '../../general';
import { groupHooks } from '../../accessControl/groupHooks';
import { IHookBank, IHookReference, IReference } from '../index.interfaces';

import HookFunction from '../../accessControl/hook';
import { IValFilter } from '../filters';
import schemaObject from './objects/object';
import schemaNested from './objects/nested';

namespace schemaValue { 
    // TODO: Remove whatever this is
    export type type = 'string' | 'number' | 'float' | 'boolean' | 'id';
    export type GqlType = 'String' | 'Int' | 'Float' | 'Boolean' | 'ID' | '[String]' | '[Int]' | '[Float]' | '[Boolean]' | '[ID]';
    export type TsType = string | number | Float64Array | boolean | string[] | number[] | Float64Array[] | boolean[];

    export interface Constructor {
        // Is this value unique?
        unique?: boolean;

        // The description of the value
        description?: string;

        // Is this value an array?
        array?: boolean;

        // This allows the user to provide a custom
        // mask for the value. eg if the key in the schema
        // is 'id', the mask will be { 'id': 1 }
        // but the key in the database is '_id'
        // So we can pass in a custom mask to the value
        // to allow for this.
        mask?: Array<string>;

        // Collection name
        name?: string;

        // Database name
        databaseName?: string;

        // The type of the value
        type: type;

        additionalValues?: boolean;

        accessControl?: HookFunction.accessControlFunc;
    } 

    export class init {
        // These are the options that are passed to the schemaObject
        options: Constructor;

        mask: {
            schema: {
                // This is the mask object used to fetch the data
                // from the database
                mask: { [key: string]: number | {} };

                // This is the array that was used to create the mask
                maskArray: Array<string>;

                // This is the key that will be used to access the value
                // Trough GraphQL.
                key: string;
            }
            database: {
                mask: { [key: string]: number | {} };
                
                maskArray: Array<string>;

                key: string;
            }
        }

        additionalValues: Array<{
            key: string;
            type: string;
            value: any;
        }> = [];

        identifier = new ObjectId();

        hooks: Array<IHookReference> = [];
        
        filters: Array<IValFilter> = [];

        key: string = '';

        type: GqlType;

        parent: IReference; 

        constructor(options: Constructor) {
            this.additionalValues = [];
            
            this.options = merge({
                unique: false,
                description: '',
                array: false,
                type: 'string',
                additionalValues: true,
            }, options);

            this.mask = {
                schema: {
                    mask: {},
                    maskArray: [],
                    key: '',
                },
                database: {
                    mask: {},
                    maskArray: [],
                    key: '',
                }  
            }

            this.#setType();
        }

        #setType(): void {
            // "string" | "number" | "boolean" | "float" | "id"
            this.type = convertType(this.options.type, this.options.array);
        }

        generateMask(parents: Array<string> = []): void {
            // We store two different types of masks in the schema
            // One is the mask passed to us by the user
            // The other is the mask that is generated by the system
            // It will be the mask used to get the data from the database
            // the other mask will be used to cast the data to the correct format

            //
            // Schema Mask
            //

            let tempMask: Array<string> = [...parents, this.key];
    
            // ---------------[ Schema Mask ]--------------- //
            // This is the mask that the user is provided

            // set the mask array
            this.mask.schema.maskArray = tempMask;

            // set the mask object
            this.mask.schema.mask = arrayToObject(this.mask.schema.maskArray);

            // set the mask key
            this.mask.schema.key = this.key;



            // -------------[ Database Mask ]-------------- //
            // This is the mask that is used to get the data from the database

            // Check if the user has provided a custom mask
            if(!this.options?.mask) {

                // If they haven't provided a custom mask
                merge(this.mask.database, this.mask.schema);

                // set the mask key for the schema mask
                this.mask.schema.key = formatValue(this.key);

                // stop here
                return;
            }

            // If the user has provided a custom mask
            this.mask.database.maskArray = [...parents, ...this.options.mask];

            // set the mask object
            this.mask.database.mask = arrayToObject(this.mask.database.maskArray);

            // set the mask key (We dont format this value as it is used in the database)
            this.mask.database.key = this.options.mask[this.options.mask.length - 1]

        }

        map(parent: schemaObject.init | schemaNested.init): void {
            merge(parent.schemaValueMap, {
                [this.mask.schema.maskArray.join()]: () => this,
            });

            merge(parent.databaseValueMap, {
                [this.mask.database.maskArray.join()]: () => this,
            });
        }

        additonalValues(): void {
            // Values can have additional values that are not in the database
            // Such as if the value is unique, or its description
            // We can add these values to the value object

            if(this.options.additionalValues === false) return;

            // Check if we have a unique value
            this.additionalValues.push({
                key: formatValue(['is', this.key , 'unique']),
                value: this.options?.unique ?? false,
                type: 'Boolean',
            });
        

            // Check if we have a description
            this.additionalValues.push({
                key: formatValue([this.key, 'description']),
                value: this.options.description || '',
                type: 'String',
            });
        }

        groupHooks(hookBank: IHookBank): void {
            // As a form of optimization, we preprocess the hooks and group them.
            // This allows us to run the hooks in a single function for multiple values. 
            // This is a lot faster than running the hooks individually, and
            // processing the hooks during the query.

            if(!this.options?.accessControl) return;

            // Initialize the access control function of this value
            const hookObject = 
                new HookFunction.init(this.options.accessControl);

            // Group the hooks together
            const grouped = groupHooks(hookBank, hookObject, this);

            // set the hook bank
            hookBank = grouped.hookBank;

            // Generate the hook references
            let hookReferences: Array<IHookReference> = [];

            // Loop through the hooks
            for(let i: number = 0; i < grouped.hookIdentifiers.length; i++) {

                // Add the hook reference to the array
                hookReferences.push({
                    identifier: grouped.hookIdentifiers[i],
                    get: () => hookBank[grouped.hookIdentifiers[i].toString()]
                });
            }

            // Set the hook references
            this.hooks = hookReferences;
        }

        setParent(parent: IReference): void {
            // Set the parent of this value     
            this.parent = parent;

            // Check if we have a unique value,Push the value to the uniqueValues array
            if(this.options?.unique === true) this.parent.get().uniqueValues.push({
                identifier: this.identifier,
                get: () => this
            });
        }
    }
}

export default schemaValue;