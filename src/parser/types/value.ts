import { merge } from 'lodash';
import { ObjectId } from 'mongodb';
import { hookReference } from '..';
import HookFunction from '../../accessControl/hook';
import { arrayToObject, formatValue } from '../../general';
import { FilterObject } from '../../graphQL/schema/types';

namespace schemaValue { 
    export type type = 'string' | 'number' | 'float' | 'boolean' | 'id';
    export type GqlType = 'String' | 'Int' | 'Float' | 'Boolean' | 'ID' | '[String]' | '[Int]' | '[Float]' | '[Boolean]' | '[ID]';
    export type TsType = string | number | Float64Array | boolean | string[] | number[] | Float64Array[] | boolean[];

    export interface Constructor {
        // Is this value unique?
        unique?: boolean;

        // The description of the value
        description?: string;

        // Is this value an array?
        array?: boolean;

        // This allows the user to provide a custom
        // mask for the value. eg if the key in the schema
        // is 'id', the mask will be { 'id': 1 }
        // but the key in the database is '_id'
        // So we can pass in a custom mask to the value
        // to allow for this.
        mask?: Array<string>;

        // Collection name
        collectionName?: string;

        // Database name
        databaseName?: string;

        // The type of the value
        type: type;

        accessControl?: HookFunction.accessControlFunc;
    } 

    export class init {
        // These are the options that are passed to the schemaObject
        options: Constructor;

        mask: {
            schema: {
                // This is the mask object used to fetch the data
                // from the database
                mask: { [key: string]: number | {} };

                // This is the array that was used to create the mask
                maskArray: Array<string>;

                // This is the key that will be used to access the value
                // Trough GraphQL.
                key: string;
            }
            database: {
                mask: { [key: string]: number | {} };
                
                maskArray: Array<string>;

                key: string;
            }
        }

        additionalValues: Array<{
            key: string;
            value: any;
        }> = [];

        identifier = new ObjectId();

        hooks: Array<hookReference> = [];
        
        filters: { [x: string]: FilterObject; } = {};

        key: string = '';

        constructor(options: Constructor) {
            this.additionalValues = [];
            
            this.options = merge({
                unique: false,
                description: '',
                array: false,
                collectionName: '',
                databaseName: '',
                type: 'string',
            }, options);

            this.mask = {
                schema: {
                    mask: {},
                    maskArray: [],
                    key: '',
                },
                database: {
                    mask: {},
                    maskArray: [],
                    key: '',
                }  
            }
        }

        generateMask(parents: Array<string> = []): void {
            // We store two different types of masks in the schema
            // One is the mask passed to us by the user
            // The other is the mask that is generated by the system
            // It will be the mask used to get the data from the database
            // the other mask will be used to cast the data to the correct format

            //
            // Schema Mask
            //

            let tempMask: Array<string> = [...parents, this.key];
    
            // ---------------[ Schema Mask ]--------------- //
            // This is the mask that the user is provided

            // set the mask array
            this.mask.schema.maskArray = tempMask;

            // set the mask object
            this.mask.schema.mask = arrayToObject(this.mask.schema.maskArray);

            // set the mask key
            this.mask.schema.key = formatValue(this.key);



            // -------------[ Database Mask ]-------------- //
            // This is the mask that is used to get the data from the database

            // Check if the user has provided a custom mask
            if(!this.options?.mask) {

                // If they haven't provided a custom mask
                merge(this.mask.database, this.mask.schema);

                // stop here
                return;
            }

            // If the user has provided a custom mask
            this.mask.database.maskArray = [...parents, ...this.options.mask];

            // set the mask object
            this.mask.database.mask = arrayToObject(this.mask.database.maskArray);

            // set the mask key
            this.mask.database.key = formatValue(this.options.mask[this.options.mask.length - 1]);
            
        }

        additonalValues(): void {
            // Values can have additional values that are not in the database
            // Such as if the value is unique, or its description
            // We can add these values to the value object

            // Check if we have a unique value
            if(this.options?.unique === true)
                this.additionalValues.push({
                    key: formatValue(['is', this.key , 'unique']),
                    value: true
            });
        

            // Check if we have a description
            if(this.options?.description)
                this.additionalValues.push({
                    key: formatValue([this.key, 'description']),
                    value: this.options.description
            });
        }
    }
}

export default schemaValue;