//
//
// This here module is responsible for parsing the request and
// Returning the correct data.
//
//

import _ from 'lodash';

import schemaObject from '../../../query/object';            // [Namespace] //
import mongoService from '../database/mongo';                      // [Interface] //

import mapResponse from '../database/mapResponse';           // [Func] //
import mapQuery from '../database/mapQuery';                 // [Func] //

import { mongoResponseObject } from '../database/mongo'; // [Interface] //
import { requestDetails } from '../..';                      // [Interface] //
import { projectionInterface } from '../database/parseQuery';

import schemaValue from '../../../query/value';

const resolve = async(
    schemaObject:  schemaObject.init,
    requestDetails: requestDetails,
    client: mongoService
): Promise<mongoResponseObject> => {
    // Start building the projection
    let projection: projectionInterface = {};

    // Map the requested resouces
    for(const paramater in requestDetails.projection[requestDetails.individualName]){
        // Get the value
        const value = schemaObject.obj[paramater] as schemaValue.init;

        // If the paramater is not found in the schema
        // It probably means that the user is trying to access a
        // that was generated by MGL, Such as IsUnique, IsRequired, etc.
        if(!value) {
            // If so, we can just generate the value here and continue
            const value = requestDetails.projection[requestDetails.individualName][paramater];

            console.log(value);
            continue;
        }

        // Merge the projections
        _.merge(projection, value.mask);
    }

    // Construct the projection
    const query: mongoResponseObject = mapQuery(
        requestDetails.arguments[requestDetails.individualName],
        schemaObject
    );

    const requestData: Array<{[x: string]: projectionInterface | mongoResponseObject}> = [
        { $project: projection },
        { $match: query }
    ];

    const collection = client.getCollection(schemaObject.options.databaseName, schemaObject.options.collectionName); 

    // Use the projection and query to get the data
    const data = await collection.aggregate(requestData).toArray();

    if(data.length === 0) return undefined;

    // Map the requested resouces back to the schema
    return mapResponse(schemaObject, data[0]);
}

export default resolve;